/*
 * glfx.js
 * http://evanw.github.com/glfx.js/
 *
 * Copyright 2011 Evan Wallace
 * Released under the MIT license
 */
var fx = (function() {
var exports = {};

// src/core/canvas.js
var gl;

function clamp(lo, value, hi) {
    return Math.max(lo, Math.min(value, hi));
}

function wrapTexture(texture) {
    return {
        _: texture,
        loadContentsOf: function(element) { this._.loadContentsOf(element); },
        destroy: function() { this._.destroy(); }
    };
}

function texture(element) {
    return wrapTexture(Texture.fromElement(element));
}

function initialize(width, height) {
    // Go for floating point buffer textures if we can, it'll make the bokeh filter look a lot better
    var type = gl.getExtension('OES_texture_float') ? gl.FLOAT : gl.UNSIGNED_BYTE;

    if (this._.texture) this._.texture.destroy();
    if (this._.spareTexture) this._.spareTexture.destroy();
    this.width = width;
    this.height = height;
    this._.texture = new Texture(width, height, gl.RGBA, type);
    this._.spareTexture = new Texture(width, height, gl.RGBA, type);
    this._.extraTexture = this._.extraTexture || new Texture(0, 0, gl.RGBA, type);
    this._.flippedShader = this._.flippedShader || new Shader(null, '\
        uniform sampler2D texture;\
        varying vec2 texCoord;\
        void main() {\
            gl_FragColor = texture2D(texture, vec2(texCoord.x, 1.0 - texCoord.y));\
        }\
    ');
    this._.isInitialized = true;
}

/*
   Draw a texture to the canvas, with an optional width and height to scale to.
   If no width and height are given then the original texture width and height
   are used.
*/
function draw(texture, width, height) {
    if (!this._.isInitialized || texture._.width != this.width || texture._.height != this.height) {
        initialize.call(this, width ? width : texture._.width, height ? height : texture._.height);
    }

    texture._.use();
    this._.texture.drawTo(function() {
        Shader.getDefaultShader().drawRect();
    });

    return this;
}

function update() {
    this._.texture.use();
    this._.flippedShader.drawRect();
    return this;
}

function simpleShader(shader, uniforms, textureIn, textureOut) {
    (textureIn || this._.texture).use();
    this._.spareTexture.drawTo(function() {
        shader.uniforms(uniforms).drawRect();
    });
    this._.spareTexture.swapWith(textureOut || this._.texture);
}

function replace(node) {
    node.parentNode.insertBefore(this, node);
    node.parentNode.removeChild(node);
    return this;
}

function contents() {
    var texture = new Texture(this._.texture.width, this._.texture.height, gl.RGBA, gl.UNSIGNED_BYTE);
    this._.texture.use();
    texture.drawTo(function() {
        Shader.getDefaultShader().drawRect();
    });
    return wrapTexture(texture);
}

/*
   Get a Uint8 array of pixel values: [r, g, b, a, r, g, b, a, ...]
   Length of the array will be width * height * 4.
*/
function getPixelArray() {
    var w = this._.texture.width;
    var h = this._.texture.height;
    var array = new Uint8Array(w * h * 4);
    this._.texture.drawTo(function() {
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, array);
    });
    return array;
}

// Fix broken toDataURL() methods on some implementations
function toDataURL(mimeType) {
    var w = this._.texture.width;
    var h = this._.texture.height;
    var array = getPixelArray.call(this);
    var canvas2d = document.createElement('canvas');
    var c = canvas2d.getContext('2d');
    canvas2d.width = w;
    canvas2d.height = h;
    var data = c.createImageData(w, h);
    for (var i = 0; i < array.length; i++) {
        data.data[i] = array[i];
    }
    c.putImageData(data, 0, 0);
    return canvas2d.toDataURL(mimeType);
}

function wrap(func) {
    return function() {
        // Make sure that we're using the correct global WebGL context
        gl = this._.gl;

        // Now that the context has been switched, we can call the wrapped function
        return func.apply(this, arguments);
    };
}

exports.canvas = function() {
    var canvas = document.createElement('canvas');
    try {
        gl = canvas.getContext('experimental-webgl', { premultipliedAlpha: false });
    } catch (e) {
        gl = null;
    }
    if (!gl) {
        throw 'This browser does not support WebGL';
    }
    canvas._ = {
        gl: gl,
        isInitialized: false,
        texture: null,
        spareTexture: null,
        flippedShader: null
    };

    // Core methods
    canvas.texture = wrap(texture);
    canvas.draw = wrap(draw);
    canvas.update = wrap(update);
    canvas.replace = wrap(replace);
    canvas.contents = wrap(contents);
    canvas.getPixelArray = wrap(getPixelArray);
    canvas.toDataURL = wrap(toDataURL);

    // Filter methods
    canvas.brightnessContrast = wrap(brightnessContrast);
    canvas.hexagonalPixelate = wrap(hexagonalPixelate);
    canvas.hueSaturation = wrap(hueSaturation);
    canvas.colorHalftone = wrap(colorHalftone);
    canvas.triangleBlur = wrap(triangleBlur);
    canvas.kaleidoscope = wrap(kaleidoscope);
    canvas.unsharpMask = wrap(unsharpMask);
    canvas.perspective = wrap(perspective);
    canvas.matrixWarp = wrap(matrixWarp);
    canvas.bulgePinch = wrap(bulgePinch);
    canvas.quadRotate = wrap(quadRotate);
    canvas.chromeLogo = wrap(chromeLogo);
    canvas.hopePoster = wrap(hopePoster);
    canvas.mirrorTube = wrap(mirrorTube);
    canvas.tiltShift = wrap(tiltShift);
    canvas.dotScreen = wrap(dotScreen);
    canvas.blockhead = wrap(blockhead);
    canvas.quadColor = wrap(quadColor);
    canvas.photocopy = wrap(photocopy);
    canvas.edgeWork = wrap(edgeWork);
    canvas.lensBlur = wrap(lensBlur);
    canvas.zoomBlur = wrap(zoomBlur);
    canvas.pixelate = wrap(pixelate);
    canvas.wetTable = wrap(wetTable);
    canvas.oldFilm = wrap(oldFilm);
    canvas.denoise = wrap(denoise);
    canvas.curves = wrap(curves);
    canvas.mirror = wrap(mirror);
    canvas.invert = wrap(invert);
    canvas.swirl = wrap(swirl);
    canvas.noise = wrap(noise);
    canvas.blend = wrap(blend);
    canvas.ink = wrap(ink);
    canvas.vhs = wrap(vhs);
    canvas.vignette = wrap(vignette);
    canvas.vibrance = wrap(vibrance);
    canvas.sepia = wrap(sepia);
    canvas.timeStrips = wrap(timeStrips);
    canvas.stamp = wrap(stamp);

    return canvas;
};
exports.splineInterpolate = splineInterpolate;

// src/core/matrix.js
// from javax.media.jai.PerspectiveTransform

function getSquareToQuad(x0, y0, x1, y1, x2, y2, x3, y3) {
    var dx1 = x1 - x2;
    var dy1 = y1 - y2;
    var dx2 = x3 - x2;
    var dy2 = y3 - y2;
    var dx3 = x0 - x1 + x2 - x3;
    var dy3 = y0 - y1 + y2 - y3;
    var det = dx1*dy2 - dx2*dy1;
    var a = (dx3*dy2 - dx2*dy3) / det;
    var b = (dx1*dy3 - dx3*dy1) / det;
    return [
        x1 - x0 + a*x1, y1 - y0 + a*y1, a,
        x3 - x0 + b*x3, y3 - y0 + b*y3, b,
        x0, y0, 1
    ];
}

function getInverse(m) {
    var a = m[0], b = m[1], c = m[2];
    var d = m[3], e = m[4], f = m[5];
    var g = m[6], h = m[7], i = m[8];
    var det = a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;
    return [
        (e*i - f*h) / det, (c*h - b*i) / det, (b*f - c*e) / det,
        (f*g - d*i) / det, (a*i - c*g) / det, (c*d - a*f) / det,
        (d*h - e*g) / det, (b*g - a*h) / det, (a*e - b*d) / det
    ];
}

function multiply(a, b) {
    return [
        a[0]*b[0] + a[1]*b[3] + a[2]*b[6],
        a[0]*b[1] + a[1]*b[4] + a[2]*b[7],
        a[0]*b[2] + a[1]*b[5] + a[2]*b[8],
        a[3]*b[0] + a[4]*b[3] + a[5]*b[6],
        a[3]*b[1] + a[4]*b[4] + a[5]*b[7],
        a[3]*b[2] + a[4]*b[5] + a[5]*b[8],
        a[6]*b[0] + a[7]*b[3] + a[8]*b[6],
        a[6]*b[1] + a[7]*b[4] + a[8]*b[7],
        a[6]*b[2] + a[7]*b[5] + a[8]*b[8]
    ];
}

// src/core/shader.js
var Shader = (function() {
    function isArray(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    }

    function isNumber(obj) {
        return Object.prototype.toString.call(obj) == '[object Number]';
    }

    function compileSource(type, source) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw 'compile error: ' + gl.getShaderInfoLog(shader);
        }
        return shader;
    }

    var defaultVertexSource = '\
    attribute vec2 vertex;\
    attribute vec2 _texCoord;\
    varying vec2 texCoord;\
    void main() {\
        texCoord = _texCoord;\
        gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);\
    }';

    var defaultFragmentSource = '\
    uniform sampler2D texture;\
    varying vec2 texCoord;\
    void main() {\
        gl_FragColor = texture2D(texture, texCoord);\
    }';

    function Shader(vertexSource, fragmentSource) {
        this.uniformLocations = {};
        this.vertexAttribute = null;
        this.texCoordAttribute = null;
        this.program = gl.createProgram();
        vertexSource = vertexSource || defaultVertexSource;
        fragmentSource = fragmentSource || defaultFragmentSource;
        fragmentSource = 'precision highp float;' + fragmentSource; // annoying requirement is annoying
        gl.attachShader(this.program, compileSource(gl.VERTEX_SHADER, vertexSource));
        gl.attachShader(this.program, compileSource(gl.FRAGMENT_SHADER, fragmentSource));
        gl.linkProgram(this.program);
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
            throw 'link error: ' + gl.getProgramInfoLog(this.program);
        }
    }

    Shader.prototype.destroy = function() {
        gl.deleteProgram(this.program);
        this.program = null;
    };

    Shader.prototype.uniforms = function(uniforms) {
        gl.useProgram(this.program);
        for (var name in uniforms) {
            if (!uniforms.hasOwnProperty(name)) continue;
            var location = this.uniformLocations[name] || (this.uniformLocations[name] = gl.getUniformLocation(this.program, name));
            if (location === null) continue; // will be null if the uniform isn't used in the shader
            var value = uniforms[name];
            if (isArray(value)) {
                switch (value.length) {
                    case 1: gl.uniform1fv(location, new Float32Array(value)); break;
                    case 2: gl.uniform2fv(location, new Float32Array(value)); break;
                    case 3: gl.uniform3fv(location, new Float32Array(value)); break;
                    case 4: gl.uniform4fv(location, new Float32Array(value)); break;
                    case 9: gl.uniformMatrix3fv(location, false, new Float32Array(value)); break;
                    case 16: gl.uniformMatrix4fv(location, false, new Float32Array(value)); break;
                    default: throw 'dont\'t know how to load uniform "' + name + '" of length ' + value.length;
                }
            } else if (isNumber(value)) {
                gl.uniform1f(location, value);
            } else {
                throw 'attempted to set uniform "' + name + '" to invalid value ' + (value || 'undefined').toString();
            }
        }
        // allow chaining
        return this;
    };

    // textures are uniforms too but for some reason can't be specified by gl.uniform1f,
    // even though floating point numbers represent the integers 0 through 7 exactly
    Shader.prototype.textures = function(textures) {
        gl.useProgram(this.program);
        for (var name in textures) {
            if (!textures.hasOwnProperty(name)) continue;
            var location = this.uniformLocations[name] || (this.uniformLocations[name] = gl.getUniformLocation(this.program, name));
            if (location === null) continue; // will be null if the uniform isn't used in the shader
            gl.uniform1i(location, textures[name]);
        }
        // allow chaining
        return this;
    };

    Shader.prototype.drawRect = function(left, top, right, bottom, cropToRect) {
        var undefined;
        var viewport = gl.getParameter(gl.VIEWPORT);
        top = top !== undefined ? (top - viewport[1]) / viewport[3] : 0;
        left = left !== undefined ? (left - viewport[0]) / viewport[2] : 0;
        right = right !== undefined ? (right - viewport[0]) / viewport[2] : 1;
        bottom = bottom !== undefined ? (bottom - viewport[1]) / viewport[3] : 1;
        if (gl.vertexBuffer == null) {
            gl.vertexBuffer = gl.createBuffer();
        }
        var vertices = [ left, top, left, bottom, right, top, right, bottom ];
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        if (gl.texCoordBuffer == null) {
            gl.texCoordBuffer = gl.createBuffer();
        }
        var coords = cropToRect ? vertices : [ 0, 0, 0, 1, 1, 0, 1, 1 ];
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords), gl.STATIC_DRAW);
        if (this.vertexAttribute == null) {
            this.vertexAttribute = gl.getAttribLocation(this.program, 'vertex');
            gl.enableVertexAttribArray(this.vertexAttribute);
        }
        if (this.texCoordAttribute == null) {
            this.texCoordAttribute = gl.getAttribLocation(this.program, '_texCoord');
            gl.enableVertexAttribArray(this.texCoordAttribute);
        }
        gl.useProgram(this.program);
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.vertexBuffer);
        gl.vertexAttribPointer(this.vertexAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.texCoordBuffer);
        gl.vertexAttribPointer(this.texCoordAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    };

    Shader.getDefaultShader = function() {
        gl.defaultShader = gl.defaultShader || new Shader();
        return gl.defaultShader;
    };

    return Shader;
})();

// src/core/spline.js
// from SplineInterpolator.cs in the Paint.NET source code

function SplineInterpolator(points) {
    var n = points.length;
    this.xa = [];
    this.ya = [];
    this.u = [];
    this.y2 = [];

    points.sort(function(a, b) {
        return a[0] - b[0];
    });
    for (var i = 0; i < n; i++) {
        this.xa.push(points[i][0]);
        this.ya.push(points[i][1]);
    }

    this.u[0] = 0;
    this.y2[0] = 0;

    for (var i = 1; i < n - 1; ++i) {
        // This is the decomposition loop of the tridiagonal algorithm. 
        // y2 and u are used for temporary storage of the decomposed factors.
        var wx = this.xa[i + 1] - this.xa[i - 1];
        var sig = (this.xa[i] - this.xa[i - 1]) / wx;
        var p = sig * this.y2[i - 1] + 2.0;

        this.y2[i] = (sig - 1.0) / p;

        var ddydx = 
            (this.ya[i + 1] - this.ya[i]) / (this.xa[i + 1] - this.xa[i]) - 
            (this.ya[i] - this.ya[i - 1]) / (this.xa[i] - this.xa[i - 1]);

        this.u[i] = (6.0 * ddydx / wx - sig * this.u[i - 1]) / p;
    }

    this.y2[n - 1] = 0;

    // This is the backsubstitution loop of the tridiagonal algorithm
    for (var i = n - 2; i >= 0; --i) {
        this.y2[i] = this.y2[i] * this.y2[i + 1] + this.u[i];
    }
}

SplineInterpolator.prototype.interpolate = function(x) {
    var n = this.ya.length;
    var klo = 0;
    var khi = n - 1;

    // We will find the right place in the table by means of
    // bisection. This is optimal if sequential calls to this
    // routine are at random values of x. If sequential calls
    // are in order, and closely spaced, one would do better
    // to store previous values of klo and khi.
    while (khi - klo > 1) {
        var k = (khi + klo) >> 1;

        if (this.xa[k] > x) {
            khi = k; 
        } else {
            klo = k;
        }
    }

    var h = this.xa[khi] - this.xa[klo];
    var a = (this.xa[khi] - x) / h;
    var b = (x - this.xa[klo]) / h;

    // Cubic spline polynomial is now evaluated.
    return a * this.ya[klo] + b * this.ya[khi] + 
        ((a * a * a - a) * this.y2[klo] + (b * b * b - b) * this.y2[khi]) * (h * h) / 6.0;
};

// src/core/texture.js
var Texture = (function() {
    Texture.fromElement = function(element) {
        var texture = new Texture(0, 0, gl.RGBA, gl.UNSIGNED_BYTE);
        texture.loadContentsOf(element);
        return texture;
    };

    function Texture(width, height, format, type) {
        this.id = gl.createTexture();
        this.width = width;
        this.height = height;
        this.format = format;
        this.type = type;

        gl.bindTexture(gl.TEXTURE_2D, this.id);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (width && height) gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
    }

    Texture.prototype.loadContentsOf = function(element) {
        this.width = element.width || element.videoWidth;
        this.height = element.height || element.videoHeight;
        gl.bindTexture(gl.TEXTURE_2D, this.id);
        gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, element);
    };

    Texture.prototype.initFromBytes = function(width, height, data) {
        this.width = width;
        this.height = height;
        this.format = gl.RGBA;
        this.type = gl.UNSIGNED_BYTE;
        gl.bindTexture(gl.TEXTURE_2D, this.id);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, this.type, new Uint8Array(data));
    };

    Texture.prototype.destroy = function() {
        gl.deleteTexture(this.id);
        this.id = null;
    };

    Texture.prototype.use = function(unit) {
        gl.activeTexture(gl.TEXTURE0 + (unit || 0));
        gl.bindTexture(gl.TEXTURE_2D, this.id);
    };

    Texture.prototype.unuse = function(unit) {
        gl.activeTexture(gl.TEXTURE0 + (unit || 0));
        gl.bindTexture(gl.TEXTURE_2D, null);
    };

    Texture.prototype.ensureFormat = function(width, height, format, type) {
        // allow passing an existing texture instead of individual arguments
        if (arguments.length == 1) {
            var texture = arguments[0];
            width = texture.width;
            height = texture.height;
            format = texture.format;
            type = texture.type;
        }

        // change the format only if required
        if (width != this.width || height != this.height || format != this.format || type != this.type) {
            this.width = width;
            this.height = height;
            this.format = format;
            this.type = type;
            gl.bindTexture(gl.TEXTURE_2D, this.id);
            gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
        }
    };

    Texture.prototype.drawTo = function(callback) {
        // start rendering to this texture
        gl.framebuffer = gl.framebuffer || gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, gl.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
        gl.viewport(0, 0, this.width, this.height);

        // do the drawing
        callback();

        // stop rendering to this texture
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };

    var canvas = null;

    function getCanvas(texture) {
        if (canvas == null) canvas = document.createElement('canvas');
        canvas.width = texture.width;
        canvas.height = texture.height;
        var c = canvas.getContext('2d');
        c.clearRect(0, 0, canvas.width, canvas.height);
        return c;
    }

    Texture.prototype.fillUsingCanvas = function(callback) {
        callback(getCanvas(this));
        this.format = gl.RGBA;
        this.type = gl.UNSIGNED_BYTE;
        gl.bindTexture(gl.TEXTURE_2D, this.id);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
        return this;
    };

    Texture.prototype.toImage = function(image) {
        this.use();
        Shader.getDefaultShader().drawRect();
        var size = this.width * this.height * 4;
        var pixels = new Uint8Array(size);
        var c = getCanvas(this);
        var data = c.createImageData(this.width, this.height);
        gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        for (var i = 0; i < size; i++) {
            data.data[i] = pixels[i];
        }
        c.putImageData(data, 0, 0);
        image.src = canvas.toDataURL();
    };

    Texture.prototype.swapWith = function(other) {
        var temp;
        temp = other.id; other.id = this.id; this.id = temp;
        temp = other.width; other.width = this.width; this.width = temp;
        temp = other.height; other.height = this.height; this.height = temp;
        temp = other.format; other.format = this.format; this.format = temp;
    };

    return Texture;
})();

// src/filters/adjust/brightnesscontrast.js
/**
 * @filter           Brightness / Contrast
 * @description      Provides additive brightness and multiplicative contrast control.
 * @param brightness -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)
 * @param contrast   -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */
function brightnessContrast(brightness, contrast) {
    gl.brightnessContrast = gl.brightnessContrast || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float brightness;\
        uniform float contrast;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            color.rgb += brightness;\
            if (contrast > 0.0) {\
                color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;\
            } else {\
                color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;\
            }\
            gl_FragColor = color;\
        }\
    ');

    simpleShader.call(this, gl.brightnessContrast, {
        brightness: clamp(-1, brightness, 1),
        contrast: clamp(-1, contrast, 1)
    });

    return this;
}

// src/filters/adjust/curves.js
function splineInterpolate(points) {
    var interpolator = new SplineInterpolator(points);
    var array = [];
    for (var i = 0; i < 256; i++) {
        array.push(clamp(0, Math.floor(interpolator.interpolate(i / 255) * 256), 255));
    }
    return array;
}

/**
 * @filter      Curves
 * @description A powerful mapping tool that transforms the colors in the image
 *              by an arbitrary function. The function is interpolated between
 *              a set of 2D points using splines. The curves filter can take
 *              either one or three arguments which will apply the mapping to
 *              either luminance or RGB values, respectively.
 * @param red   A list of points that define the function for the red channel.
 *              Each point is a list of two values: the value before the mapping
 *              and the value after the mapping, both in the range 0 to 1. For
 *              example, [[0,1], [1,0]] would invert the red channel while
 *              [[0,0], [1,1]] would leave the red channel unchanged. If green
 *              and blue are omitted then this argument also applies to the
 *              green and blue channels.
 * @param green (optional) A list of points that define the function for the green
 *              channel (just like for red).
 * @param blue  (optional) A list of points that define the function for the blue
 *              channel (just like for red).
 */
function curves(red, green, blue) {
    // Create the ramp texture
    red = splineInterpolate(red);
    if (arguments.length == 1) {
        green = blue = red;
    } else {
        green = splineInterpolate(green);
        blue = splineInterpolate(blue);
    }
    var array = [];
    for (var i = 0; i < 256; i++) {
        array.splice(array.length, 0, red[i], green[i], blue[i], 255);
    }
    this._.extraTexture.initFromBytes(256, 1, array);
    this._.extraTexture.use(1);

    gl.curves = gl.curves || new Shader(null, '\
        uniform sampler2D texture;\
        uniform sampler2D map;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            color.r = texture2D(map, vec2(color.r)).r;\
            color.g = texture2D(map, vec2(color.g)).g;\
            color.b = texture2D(map, vec2(color.b)).b;\
            gl_FragColor = color;\
        }\
    ');

    gl.curves.textures({
        map: 1
    });
    simpleShader.call(this, gl.curves, {});

    return this;
}

// src/filters/adjust/denoise.js
/**
 * @filter         Denoise
 * @description    Smooths over grainy noise in dark images using an 9x9 box filter
 *                 weighted by color intensity, similar to a bilateral filter.
 * @param exponent The exponent of the color intensity difference, should be greater
 *                 than zero. A value of zero just gives an 9x9 box blur and high values
 *                 give the original image, but ideal values are usually around 10-20.
 */
function denoise(exponent) {
    // Do a 9x9 bilateral box filter
    gl.denoise = gl.denoise || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float exponent;\
        uniform float strength;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        void main() {\
            vec4 center = texture2D(texture, texCoord);\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            for (float x = -4.0; x <= 4.0; x += 1.0) {\
                for (float y = -4.0; y <= 4.0; y += 1.0) {\
                    vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);\
                    float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));\
                    weight = pow(weight, exponent);\
                    color += sample * weight;\
                    total += weight;\
                }\
            }\
            gl_FragColor = color / total;\
        }\
    ');

    // Perform two iterations for stronger results
    for (var i = 0; i < 2; i++) {
        simpleShader.call(this, gl.denoise, {
            exponent: Math.max(0, exponent),
            texSize: [this.width, this.height]
        });
    }

    return this;
}

// src/filters/adjust/huesaturation.js
/**
 * @filter           Hue / Saturation
 * @description      Provides rotational hue and multiplicative saturation control. RGB color space
 *                   can be imagined as a cube where the axes are the red, green, and blue color
 *                   values. Hue changing works by rotating the color vector around the grayscale
 *                   line, which is the straight line from black (0, 0, 0) to white (1, 1, 1).
 *                   Saturation is implemented by scaling all color channel values either toward
 *                   or away from the average color channel value.
 * @param hue        -1 to 1 (-1 is 180 degree rotation in the negative direction, 0 is no change,
 *                   and 1 is 180 degree rotation in the positive direction)
 * @param saturation -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */
function hueSaturation(hue, saturation) {
    gl.hueSaturation = gl.hueSaturation || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float hue;\
        uniform float saturation;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            \
            /* hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}] */\
            float angle = hue * 3.14159265;\
            float s = sin(angle), c = cos(angle);\
            vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\
            float len = length(color.rgb);\
            color.rgb = vec3(\
                dot(color.rgb, weights.xyz),\
                dot(color.rgb, weights.zxy),\
                dot(color.rgb, weights.yzx)\
            );\
            \
            /* saturation adjustment */\
            float average = (color.r + color.g + color.b) / 3.0;\
            if (saturation > 0.0) {\
                color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));\
            } else {\
                color.rgb += (average - color.rgb) * (-saturation);\
            }\
            \
            gl_FragColor = color;\
        }\
    ');

    simpleShader.call(this, gl.hueSaturation, {
        hue: clamp(-1, hue, 1),
        saturation: clamp(-1, saturation, 1)
    });

    return this;
}

// src/filters/adjust/noise.js
/**
 * @filter         Noise
 * @description    Adds black and white noise to the image.
 * @param amount   0 to 1 (0 for no effect, 1 for maximum noise)
 */
function noise(amount) {
    gl.noise = gl.noise || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float amount;\
        varying vec2 texCoord;\
        float rand(vec2 co) {\
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\
        }\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            \
            float diff = (rand(texCoord) - 0.5) * amount;\
            color.r += diff;\
            color.g += diff;\
            color.b += diff;\
            \
            gl_FragColor = color;\
        }\
    ');

    simpleShader.call(this, gl.noise, {
        amount: clamp(0, amount, 1)
    });

    return this;
}

// src/filters/adjust/sepia.js
/**
 * @filter         Sepia
 * @description    Gives the image a reddish-brown monochrome tint that imitates an old photograph.
 * @param amount   0 to 1 (0 for no effect, 1 for full sepia coloring)
 */
function sepia(amount) {
    gl.sepia = gl.sepia || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float amount;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            float r = color.r;\
            float g = color.g;\
            float b = color.b;\
            \
            color.r = min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));\
            color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));\
            color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));\
            \
            gl_FragColor = color;\
        }\
    ');

    simpleShader.call(this, gl.sepia, {
        amount: clamp(0, amount, 1)
    });

    return this;
}

// src/filters/adjust/unsharpmask.js
/**
 * @filter         Unsharp Mask
 * @description    A form of image sharpening that amplifies high-frequencies in the image. It
 *                 is implemented by scaling pixels away from the average of their neighbors.
 * @param radius   The blur radius that calculates the average of the neighboring pixels.
 * @param strength A scale factor where 0 is no effect and higher values cause a stronger effect.
 */
function unsharpMask(radius, strength) {
    gl.unsharpMask = gl.unsharpMask || new Shader(null, '\
        uniform sampler2D blurredTexture;\
        uniform sampler2D originalTexture;\
        uniform float strength;\
        uniform float threshold;\
        varying vec2 texCoord;\
        void main() {\
            vec4 blurred = texture2D(blurredTexture, texCoord);\
            vec4 original = texture2D(originalTexture, texCoord);\
            gl_FragColor = mix(blurred, original, 1.0 + strength);\
        }\
    ');

    // Store a copy of the current texture in the second texture unit
    this._.extraTexture.ensureFormat(this._.texture);
    this._.texture.use();
    this._.extraTexture.drawTo(function() {
        Shader.getDefaultShader().drawRect();
    });

    // Blur the current texture, then use the stored texture to detect edges
    this._.extraTexture.use(1);
    this.triangleBlur(radius);
    gl.unsharpMask.textures({
        originalTexture: 1
    });
    simpleShader.call(this, gl.unsharpMask, {
        strength: strength
    });
    this._.extraTexture.unuse(1);

    return this;
}

// src/filters/adjust/vibrance.js
/**
 * @filter       Vibrance
 * @description  Modifies the saturation of desaturated colors, leaving saturated colors unmodified.
 * @param amount -1 to 1 (-1 is minimum vibrance, 0 is no change, and 1 is maximum vibrance)
 */
function vibrance(amount) {
    gl.vibrance = gl.vibrance || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float amount;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            float average = (color.r + color.g + color.b) / 3.0;\
            float mx = max(color.r, max(color.g, color.b));\
            float amt = (mx - average) * (-amount * 3.0);\
            color.rgb = mix(color.rgb, vec3(mx), amt);\
            gl_FragColor = color;\
        }\
    ');

    simpleShader.call(this, gl.vibrance, {
        amount: clamp(-1, amount, 1)
    });

    return this;
}

// src/filters/adjust/vignette.js
/**
 * @filter         Vignette
 * @description    Adds a simulated lens edge darkening effect.
 * @param size     0 to 1 (0 for center of frame, 1 for edge of frame)
 * @param amount   0 to 1 (0 for no effect, 1 for maximum lens darkening)
 */
function vignette(size, amount) {
    gl.vignette = gl.vignette || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float size;\
        uniform float amount;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            \
            float dist = distance(texCoord, vec2(0.5, 0.5));\
            color.rgb *= smoothstep(0.8, size * 0.799, dist * (amount + size));\
            \
            gl_FragColor = color;\
        }\
    ');

    simpleShader.call(this, gl.vignette, {
        size: clamp(0, size, 1),
        amount: clamp(0, amount, 1)
    });

    return this;
}

// src/filters/blur/lensblur.js
/**
 * @filter           Lens Blur
 * @description      Imitates a camera capturing the image out of focus by using a blur that generates
 *                   the large shapes known as bokeh. The polygonal shape of real bokeh is due to the
 *                   blades of the aperture diaphragm when it isn't fully open. This blur renders
 *                   bokeh from a 6-bladed diaphragm because the computation is more efficient. It
 *                   can be separated into three rhombi, each of which is just a skewed box blur.
 *                   This filter makes use of the floating point texture WebGL extension to implement
 *                   the brightness parameter, so there will be severe visual artifacts if brightness
 *                   is non-zero and the floating point texture extension is not available. The
 *                   idea was from John White's SIGGRAPH 2011 talk but this effect has an additional
 *                   brightness parameter that fakes what would otherwise come from a HDR source.
 * @param radius     the radius of the hexagonal disk convolved with the image
 * @param brightness -1 to 1 (the brightness of the bokeh, negative values will create dark bokeh)
 * @param angle      the rotation of the bokeh in radians
 */
function lensBlur(radius, brightness, angle) {
    // All averaging is done on values raised to a power to make more obvious bokeh
    // (we will raise the average to the inverse power at the end to compensate).
    // Without this the image looks almost like a normal blurred image. This hack is
    // obviously not realistic, but to accurately simulate this we would need a high
    // dynamic range source photograph which we don't have.
    gl.lensBlurPrePass = gl.lensBlurPrePass || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float power;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            color = pow(color, vec4(power));\
            gl_FragColor = vec4(color);\
        }\
    ');

    var common = '\
        uniform sampler2D texture0;\
        uniform sampler2D texture1;\
        uniform vec2 delta0;\
        uniform vec2 delta1;\
        uniform float power;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        vec4 sample(vec2 delta) {\
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(delta, 151.7182), 0.0);\
            \
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            for (float t = 0.0; t <= 30.0; t++) {\
                float percent = (t + offset) / 30.0;\
                color += texture2D(texture0, texCoord + delta * percent);\
                total += 1.0;\
            }\
            return color / total;\
        }\
    ';

    gl.lensBlur0 = gl.lensBlur0 || new Shader(null, common + '\
        void main() {\
            gl_FragColor = sample(delta0);\
        }\
    ');
    gl.lensBlur1 = gl.lensBlur1 || new Shader(null, common + '\
        void main() {\
            gl_FragColor = (sample(delta0) + sample(delta1)) * 0.5;\
        }\
    ');
    gl.lensBlur2 = gl.lensBlur2 || new Shader(null, common + '\
        void main() {\
            vec4 color = (sample(delta0) + 2.0 * texture2D(texture1, texCoord)) / 3.0;\
            gl_FragColor = pow(color, vec4(power));\
        }\
    ').textures({ texture1: 1 });

    // Generate
    var dir = [];
    for (var i = 0; i < 3; i++) {
        var a = angle + i * Math.PI * 2 / 3;
        dir.push([radius * Math.sin(a) / this.width, radius * Math.cos(a) / this.height]);
    }
    var power = Math.pow(10, clamp(-1, brightness, 1));

    // Remap the texture values, which will help make the bokeh effect
    simpleShader.call(this, gl.lensBlurPrePass, {
        power: power
    });

    // Blur two rhombi in parallel into extraTexture
    this._.extraTexture.ensureFormat(this._.texture);
    simpleShader.call(this, gl.lensBlur0, {
        delta0: dir[0]
    }, this._.texture, this._.extraTexture);
    simpleShader.call(this, gl.lensBlur1, {
        delta0: dir[1],
        delta1: dir[2]
    }, this._.extraTexture, this._.extraTexture);

    // Blur the last rhombus and combine with extraTexture
    simpleShader.call(this, gl.lensBlur0, {
        delta0: dir[1]
    });
    this._.extraTexture.use(1);
    simpleShader.call(this, gl.lensBlur2, {
        power: 1 / power,
        delta0: dir[2]
    });

    return this;
}

// src/filters/blur/pixelate.js
/**
 * @filter        Pixelate
 * @description   Renders the image at a lower resolution using square tiles. Tile colors
 *                are nearest-neighbor sampled from the centers of the tiles.
 * @param centerX The x coordinate of the pattern center.
 * @param centerY The y coordinate of the pattern center.
 * @param scale   The width of an individual tile, in pixels.
 */
function pixelate(centerX, centerY, scale) {
    gl.pixelate = gl.pixelate || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float scale;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        void main() {\
            vec2 tex = (texCoord * texSize - center) / scale;\
            vec2 choice = floor(tex) + 0.5;\
            choice *= scale / texSize;\
            gl_FragColor = texture2D(texture, choice + center / texSize);\
        }\
    ');

    simpleShader.call(this, gl.pixelate, {
        center: [centerX, centerY],
        scale: scale,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/blur/tiltshift.js
/**
 * @filter               Tilt Shift
 * @description          Simulates the shallow depth of field normally encountered in close-up
 *                       photography, which makes the scene seem much smaller than it actually
 *                       is. This filter assumes the scene is relatively planar, in which case
 *                       the part of the scene that is completely in focus can be described by
 *                       a line (the intersection of the focal plane and the scene). An example
 *                       of a planar scene might be looking at a road from above at a downward
 *                       angle. The image is then blurred with a blur radius that starts at zero
 *                       on the line and increases further from the line.
 * @param startX         The x coordinate of the start of the line segment.
 * @param startY         The y coordinate of the start of the line segment.
 * @param endX           The x coordinate of the end of the line segment.
 * @param endY           The y coordinate of the end of the line segment.
 * @param blurRadius     The maximum radius of the pyramid blur.
 * @param gradientRadius The distance from the line at which the maximum blur radius is reached.
 */
function tiltShift(startX, startY, endX, endY, blurRadius, gradientRadius) {
    gl.tiltShift = gl.tiltShift || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float blurRadius;\
        uniform float gradientRadius;\
        uniform vec2 start;\
        uniform vec2 end;\
        uniform vec2 delta;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\
            float radius = smoothstep(0.0, 1.0, abs(dot(texCoord * texSize - start, normal)) / gradientRadius) * blurRadius;\
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec4 sample = texture2D(texture, texCoord + delta / texSize * percent * radius);\
                \
                /* switch to pre-multiplied alpha to correctly blur transparent images */\
                sample.rgb *= sample.a;\
                \
                color += sample * weight;\
                total += weight;\
            }\
            \
            gl_FragColor = color / total;\
            \
            /* switch back from pre-multiplied alpha */\
            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\
        }\
    ');

    var dx = endX - startX;
    var dy = endY - startY;
    var d = Math.sqrt(dx * dx + dy * dy);
    simpleShader.call(this, gl.tiltShift, {
        blurRadius: blurRadius,
        gradientRadius: gradientRadius,
        start: [startX, startY],
        end: [endX, endY],
        delta: [dx / d, dy / d],
        texSize: [this.width, this.height]
    });
    simpleShader.call(this, gl.tiltShift, {
        blurRadius: blurRadius,
        gradientRadius: gradientRadius,
        start: [startX, startY],
        end: [endX, endY],
        delta: [-dy / d, dx / d],
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/blur/triangleblur.js
/**
 * @filter       Triangle Blur
 * @description  This is the most basic blur filter, which convolves the image with a
 *               pyramid filter. The pyramid filter is separable and is applied as two
 *               perpendicular triangle filters.
 * @param radius The radius of the pyramid convolved with the image.
 */
function triangleBlur(radius) {
    gl.triangleBlur = gl.triangleBlur || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 delta;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec4 sample = texture2D(texture, texCoord + delta * percent);\
                \
                /* switch to pre-multiplied alpha to correctly blur transparent images */\
                sample.rgb *= sample.a;\
                \
                color += sample * weight;\
                total += weight;\
            }\
            \
            gl_FragColor = color / total;\
            \
            /* switch back from pre-multiplied alpha */\
            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\
        }\
    ');

    simpleShader.call(this, gl.triangleBlur, {
        delta: [radius / this.width, 0]
    });
    simpleShader.call(this, gl.triangleBlur, {
        delta: [0, radius / this.height]
    });

    return this;
}

// src/filters/blur/zoomblur.js
/**
 * @filter          Zoom Blur
 * @description     Blurs the image away from a certain point, which looks like radial motion blur.
 * @param centerX   The x coordinate of the blur origin.
 * @param centerY   The y coordinate of the blur origin.
 * @param strength  The strength of the blur. Values in the range 0 to 1 are usually sufficient,
 *                  where 0 doesn't change the image and 1 creates a highly blurred image.
 * @param minRadius The radius inside which this filter has no effect.
 */
function zoomBlur(centerX, centerY, strength, minRadius) {
    gl.zoomBlur = gl.zoomBlur || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float minRadius;\
        uniform float strength;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            vec2 toCenter = center - texCoord * texSize;\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            for (float t = 0.0; t <= 40.0; t++) {\
                float percent = (t + offset) / 40.0;\
                float weight = percent - percent * percent;\
                percent *= 1.0 - 1.0 / (1.0 + 0.5 * (max(length(toCenter), minRadius) - minRadius) / (minRadius + 0.00001));\
                vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);\
                \
                /* switch to pre-multiplied alpha to correctly blur transparent images */\
                sample.rgb *= sample.a;\
                \
                color += sample * weight;\
                total += weight;\
            }\
            \
            gl_FragColor = color / total;\
            \
            /* switch back from pre-multiplied alpha */\
            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\
        }\
    ');

    simpleShader.call(this, gl.zoomBlur, {
        center: [centerX, centerY],
        minRadius: minRadius,
        strength: strength,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/fun/colorhalftone.js
/**
 * @filter        Color Halftone
 * @description   Simulates a CMYK halftone rendering of the image by multiplying pixel values
 *                with a four rotated 2D sine wave patterns, one each for cyan, magenta, yellow,
 *                and black.
 * @param centerX The x coordinate of the pattern origin.
 * @param centerY The y coordinate of the pattern origin.
 * @param angle   The rotation of the pattern in radians.
 * @param size    The diameter of a dot in pixels.
 */
function colorHalftone(centerX, centerY, angle, size) {
    gl.colorHalftone = gl.colorHalftone || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float angle;\
        uniform float scale;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        \
        float pattern(float angle) {\
            float s = sin(angle), c = cos(angle);\
            vec2 tex = texCoord * texSize - center;\
            vec2 point = vec2(\
                c * tex.x - s * tex.y,\
                s * tex.x + c * tex.y\
            ) * scale;\
            return (sin(point.x) * sin(point.y)) * 4.0;\
        }\
        \
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            vec3 cmy = 1.0 - color.rgb;\
            float k = min(cmy.x, min(cmy.y, cmy.z));\
            cmy = (cmy - k) / (1.0 - k);\
            cmy = clamp(cmy * 10.0 - 3.0 + vec3(pattern(angle + 0.26179), pattern(angle + 1.30899), pattern(angle)), 0.0, 1.0);\
            k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539), 0.0, 1.0);\
            gl_FragColor = vec4(1.0 - cmy - k, color.a);\
        }\
    ');

    simpleShader.call(this, gl.colorHalftone, {
        center: [centerX, centerY],
        angle: angle,
        scale: Math.PI / size,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/fun/dotscreen.js
/**
 * @filter        Dot Screen
 * @description   Simulates a black and white halftone rendering of the image by multiplying
 *                pixel values with a rotated 2D sine wave pattern.
 * @param centerX The x coordinate of the pattern origin.
 * @param centerY The y coordinate of the pattern origin.
 * @param angle   The rotation of the pattern in radians.
 * @param size    The diameter of a dot in pixels.
 */
function dotScreen(centerX, centerY, angle, size) {
    gl.dotScreen = gl.dotScreen || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float angle;\
        uniform float scale;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        \
        float pattern() {\
            float s = sin(angle), c = cos(angle);\
            vec2 tex = texCoord * texSize - center;\
            vec2 point = vec2(\
                c * tex.x - s * tex.y,\
                s * tex.x + c * tex.y\
            ) * scale;\
            return (sin(point.x) * sin(point.y)) * 4.0;\
        }\
        \
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            float average = (color.r + color.g + color.b) / 3.0;\
            gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\
        }\
    ');

    simpleShader.call(this, gl.dotScreen, {
        center: [centerX, centerY],
        angle: angle,
        scale: Math.PI / size,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/fun/edgework.js
/**
 * @filter       Edge Work
 * @description  Picks out different frequencies in the image by subtracting two
 *               copies of the image blurred with different radii.
 * @param radius The radius of the effect in pixels.
 */
function edgeWork(radius) {
    gl.edgeWork1 = gl.edgeWork1 || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 delta;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec2 color = vec2(0.0);\
            vec2 total = vec2(0.0);\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec3 sample = texture2D(texture, texCoord + delta * percent).rgb;\
                float average = (sample.r + sample.g + sample.b) / 3.0;\
                color.x += average * weight;\
                total.x += weight;\
                if (abs(t) < 15.0) {\
                    weight = weight * 2.0 - 1.0;\
                    color.y += average * weight;\
                    total.y += weight;\
                }\
            }\
            gl_FragColor = vec4(color / total, 0.0, 1.0);\
        }\
    ');
    gl.edgeWork2 = gl.edgeWork2 || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 delta;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        void main() {\
            vec2 color = vec2(0.0);\
            vec2 total = vec2(0.0);\
            \
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            for (float t = -30.0; t <= 30.0; t++) {\
                float percent = (t + offset - 0.5) / 30.0;\
                float weight = 1.0 - abs(percent);\
                vec2 sample = texture2D(texture, texCoord + delta * percent).xy;\
                color.x += sample.x * weight;\
                total.x += weight;\
                if (abs(t) < 15.0) {\
                    weight = weight * 2.0 - 1.0;\
                    color.y += sample.y * weight;\
                    total.y += weight;\
                }\
            }\
            float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);\
            gl_FragColor = vec4(c, c, c, 1.0);\
        }\
    ');

    simpleShader.call(this, gl.edgeWork1, {
        delta: [radius / this.width, 0]
    });
    simpleShader.call(this, gl.edgeWork2, {
        delta: [0, radius / this.height]
    });

    return this;
}

// src/filters/fun/hexagonalpixelate.js
/**
 * @filter        Hexagonal Pixelate
 * @description   Renders the image using a pattern of hexagonal tiles. Tile colors
 *                are nearest-neighbor sampled from the centers of the tiles.
 * @param centerX The x coordinate of the pattern center.
 * @param centerY The y coordinate of the pattern center.
 * @param scale   The width of an individual tile, in pixels.
 */
function hexagonalPixelate(centerX, centerY, scale) {
    gl.hexagonalPixelate = gl.hexagonalPixelate || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float scale;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        void main() {\
            vec2 tex = (texCoord * texSize - center) / scale;\
            tex.y /= 0.866025404;\
            tex.x -= tex.y * 0.5;\
            \
            vec2 a;\
            if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) a = vec2(floor(tex.x), floor(tex.y));\
            else a = vec2(ceil(tex.x), ceil(tex.y));\
            vec2 b = vec2(ceil(tex.x), floor(tex.y));\
            vec2 c = vec2(floor(tex.x), ceil(tex.y));\
            \
            vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\
            vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\
            vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\
            vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\
            \
            float alen = length(TEX - A);\
            float blen = length(TEX - B);\
            float clen = length(TEX - C);\
            \
            vec2 choice;\
            if (alen < blen) {\
                if (alen < clen) choice = a;\
                else choice = c;\
            } else {\
                if (blen < clen) choice = b;\
                else choice = c;\
            }\
            \
            choice.x += choice.y * 0.5;\
            choice.y *= 0.866025404;\
            choice *= scale / texSize;\
            gl_FragColor = texture2D(texture, choice + center / texSize);\
        }\
    ');

    simpleShader.call(this, gl.hexagonalPixelate, {
        center: [centerX, centerY],
        scale: scale,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/fun/hopeposter.js
/**
 * @filter           Hope Poster
 * @description      Posterize the image using the colors in the famous Obama "hope" poster.
 */
function hopePoster(centerX, centerY, angle, radius, isInfinite) {
    gl.hopePoster = gl.hopePoster || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        \
        void main() {\
            vec2 dx = vec2(1.0 / texSize.x, 0.0);\
            vec2 dy = vec2(0.0, 1.0 / texSize.y);\
            vec4 color = texture2D(texture, texCoord);\
            float bigTotal = 0.0;\
            float smallTotal = 0.0;\
            vec3 bigAverage = vec3(0.0);\
            vec3 smallAverage = vec3(0.0);\
            for (float x = -2.0; x <= 2.0; x += 1.0) {\
                for (float y = -2.0; y <= 2.0; y += 1.0) {\
                    vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;\
                    bigAverage += sample;\
                    bigTotal += 1.0;\
                    if (abs(x) + abs(y) < 2.0) {\
                        smallAverage += sample;\
                        smallTotal += 1.0;\
                    }\
                }\
            }\
            vec3 edges = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\
            float edge = dot(edges, edges) * 10000.0;\
            edge = edge * 100.0 - 50.0;\
            \
            float gray = (color.r + color.g + color.b) / 3.0;\
            if (gray < 0.3 || edge > 0.5) color.rgb = vec3(0.0, 0.2, 0.3);\
            else if (gray < 0.35) color.rgb = vec3(0.85, 0.1, 0.13);\
            else if (gray < 0.5 || gray < 0.55 && fract(gl_FragCoord.y * 0.5) < 0.5) color.rgb = vec3(0.45, 0.59, 0.62);\
            else color.rgb = vec3(0.98, 0.9, 0.64);\
            \
            gl_FragColor = color;\
        }\
    ');

    triangleBlur.call(this, 3);
    simpleShader.call(this, gl.hopePoster, {
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/fun/ink.js
/**
 * @filter         Ink
 * @description    Simulates outlining the image in ink by darkening edges stronger than a
 *                 certain threshold. The edge detection value is the difference of two
 *                 copies of the image, each blurred using a blur of a different radius.
 * @param strength The multiplicative scale of the ink edges. Values in the range 0 to 1
 *                 are usually sufficient, where 0 doesn't change the image and 1 adds lots
 *                 of black edges. Negative strength values will create white ink edges
 *                 instead of black ones.
 */
function ink(strength) {
    gl.ink = gl.ink || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float strength;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        void main() {\
            vec2 dx = vec2(1.0 / texSize.x, 0.0);\
            vec2 dy = vec2(0.0, 1.0 / texSize.y);\
            vec4 color = texture2D(texture, texCoord);\
            float bigTotal = 0.0;\
            float smallTotal = 0.0;\
            vec3 bigAverage = vec3(0.0);\
            vec3 smallAverage = vec3(0.0);\
            for (float x = -2.0; x <= 2.0; x += 1.0) {\
                for (float y = -2.0; y <= 2.0; y += 1.0) {\
                    vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;\
                    bigAverage += sample;\
                    bigTotal += 1.0;\
                    if (abs(x) + abs(y) < 2.0) {\
                        smallAverage += sample;\
                        smallTotal += 1.0;\
                    }\
                }\
            }\
            vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);\
            gl_FragColor = vec4(clamp(color.rgb - dot(edge, edge) * strength * 100000.0, 0.0, 1.0), color.a);\
        }\
    ');

    simpleShader.call(this, gl.ink, {
        strength: strength * strength * strength * strength * strength,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/fun/invert.js
/**
 * @filter         Invert
 * @description    Inverts all color channels.
 */
function invert() {
    gl.invert = gl.invert || new Shader(null, '\
        uniform sampler2D texture;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            gl_FragColor = vec4(1.0 - color.rgb, color.a);\
        }\
    ');

    simpleShader.call(this, gl.invert);

    return this;
}

// src/filters/other/blend.js
/**
 * @filter        Blend
 * @description   Linearly interpolates between the current texture and the
 *                provided texture.
 * @param texture The other texture to blend with.
 * @param alpha   Specifies how much of each image to include. 0 means none of
 *                the provided texture and 1 means all of the provided texture.
 */
function blend(texture, alpha) {
    gl.blend = gl.blend || new Shader(null, '\
        uniform sampler2D texture;\
        uniform sampler2D other;\
        uniform float alpha;\
        varying vec2 texCoord;\
        void main() {\
            gl_FragColor = mix(texture2D(texture, texCoord), texture2D(other, texCoord), alpha);\
        }\
    ');

    (texture._ || texture).use(1);
    gl.blend.textures({ other: 1 });
    simpleShader.call(this, gl.blend, { alpha: alpha });

    return this;
}

// src/filters/other/common.js
function warpShader(uniforms, warp) {
    return new Shader(null, uniforms + '\
    uniform sampler2D texture;\
    uniform vec2 texSize;\
    varying vec2 texCoord;\
    void main() {\
        vec2 coord = texCoord * texSize;\
        ' + warp + '\
        gl_FragColor = texture2D(texture, coord / texSize);\
        vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);\
        if (coord != clampedCoord) {\
            /* fade to transparent if we are outside the image */\
            gl_FragColor.a *= max(0.0, 1.0 - length(coord - clampedCoord));\
        }\
    }');
}

// returns a random number between 0 and 1
var randomShaderFunc = '\
    float random(vec3 scale, float seed) {\
        /* use the fragment position for a different seed per-pixel */\
        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\
    }\
';

// src/filters/other/stamp.js
/**
 * @filter          Stamp
 * @description     Stamps an image on top of the current canvas contents in
 *                  potentially multiple positions. This call renders a batch
 *                  of sprites in a single call instead of only one stamp for
 *                  performance reasons.
 * @param positions An array of arrays where each inner array represents one
 *                  stamp and has the format [centerX, centerY, scaleX, scaleY,
 *                  rotation, alpha]. The rotation is in radians and the
 *                  alpha is from 0 to 1.
 * @param texture   A texture containing the image to be stamped.
 */
function stamp(positions, texture) {
    gl.stamp = gl.stamp || new Shader('\
        attribute vec2 vertex;\
        attribute vec3 _texCoord;\
        varying vec3 texCoord;\
        void main() {\
            texCoord = _texCoord;\
            gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);\
        }\
    ', '\
        uniform sampler2D texture;\
        uniform vec2 texSize;\
        varying vec3 texCoord;\
        void main() {\
            gl_FragColor = texture2D(texture, texCoord.xy) * vec4(vec3(1.0), texCoord.z);\
        }\
    ');

    var canvas = this;
    texture = texture._ || texture;
    gl.stamp.uniforms({ texSize: [this.width, this.height] });
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    this._.spareTexture.drawTo(function() {
        // Copy the current texture into spareTexture first
        canvas._.texture.use();
        Shader.getDefaultShader().drawRect();

        // Generate the geometry
        var vertices = [], coords = [];
        var w = texture.width, h = texture.height;
        for (var i = 0; i < positions.length; i++) {
            var pos = positions[i];
            var centerX = pos[0], centerY = pos[1], scaleX = pos[2], scaleY = pos[3], rotation = pos[4], alpha = pos[5];
            var s = Math.sin(rotation), c = Math.cos(rotation);
            for (var j = 0; j < 4; j++) {
                var x = j % 2, y = j / 2 | 0;
                coords.splice(coords.length, 0, x, y, alpha);
                x = (x - 0.5) * w * scaleX;
                y = (y - 0.5) * h * scaleY;
                vertices.splice(vertices.length, 0,
                    (centerX + x * c + y * s) / canvas.width,
                    (centerY + y * c - x * s) / canvas.height);
            }
        }

        // Bind the vertices
        if (gl.vertexBuffer == null) gl.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        if (gl.stamp.vertexAttribute == null) {
            gl.stamp.vertexAttribute = gl.getAttribLocation(gl.stamp.program, 'vertex');
            gl.enableVertexAttribArray(gl.stamp.vertexAttribute);
        }

        // Bind the texture coordinates (and alpha)
        if (gl.texCoordBuffer == null) gl.texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coords), gl.STATIC_DRAW);
        if (gl.stamp.texCoordAttribute == null) {
            gl.stamp.texCoordAttribute = gl.getAttribLocation(gl.stamp.program, '_texCoord');
            gl.enableVertexAttribArray(gl.stamp.texCoordAttribute);
        }

        // Draw the stamps
        texture.use();
        gl.useProgram(gl.stamp.program);
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.vertexBuffer);
        gl.vertexAttribPointer(gl.stamp.vertexAttribute, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.texCoordBuffer);
        gl.vertexAttribPointer(gl.stamp.texCoordAttribute, 3, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    });
    gl.disable(gl.BLEND);
    this._.spareTexture.swapWith(this._.texture);

    return this;
}

// src/filters/video/chromelogo.js
/**
 * @filter           Chrome Logo
 * @description      Overlays the logo of the Chrome browser.
 * @param centerX    The x coordinate of the logo.
 * @param centerY    The y coordinate of the logo.
 * @param frame      The frame number of the swirling animation.
 * @param blueRadius The radius of the blue center.
 */
function chromeLogo(centerX, centerY, frame, blueRadius) {
    gl.chromeLogo = gl.chromeLogo || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float frame;\
        uniform float blueRadius;\
        uniform vec2 center;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        ' + randomShaderFunc + '\
        \
        const float twopi = 6.283185307179586;\
        \
        vec3 colorAt(vec2 coord, float twist) {\
            float radius = length(coord);\
            float offset = radius * 0.005;\
            float angle = fract((atan(coord.y, coord.x) - offset) / twopi + twist) * 3.0;\
            const vec3 red = vec3(1.0, 0.25, 0.0);\
            const vec3 green = vec3(0.5, 0.75, 0.25);\
            const vec3 yellow = vec3(1.0, 1.0, 0.25);\
            const vec3 blue = vec3(0.35, 0.6, 0.85);\
            vec3 color;\
            float t = 1.0 / (1.0 + exp(-100.0 * (fract(angle) - 0.5)));\
            if (angle < 1.0) color = mix(red, yellow, t);\
            else if (angle < 2.0) color = mix(yellow, green, t);\
            else color = mix(green, red, t);\
            color = mix(color, blue, 1.0 / (1.0 + exp(-50.0 * (1.0 - radius / blueRadius))));\
            return color;\
        }\
        \
        vec4 bulgySample(vec2 coord) {\
            float bulge = 1.5 * length(coord) / blueRadius;\
            return texture2D(texture, (coord / (1.0 + 5.0 / (exp(-bulge) + exp(bulge))) + center) / texSize);\
        }\
        \
        void main() {\
            /* randomize the lookup values to hide the fixed number of samples */\
            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\
            \
            vec2 coord = texCoord * texSize - center;\
            float twist = 2.0 * (fract(frame * 0.005 + 0.5) - 0.5);\
            float reset = twist * twist;\
            reset *= reset * reset;\
            reset *= reset * reset;\
            reset *= reset * reset;\
            float sign = (twist > 0.0 ? 1.0 : -1.0);\
            float radius = length(coord);\
            vec2 tangent = vec2(-coord.y, coord.x) / radius;\
            vec4 color = vec4(0.0);\
            float total = 0.0;\
            for (float t = 0.0; t <= 20.0; t++) {\
                float percent = (t + offset) / 20.0;\
                float weight = percent - percent * percent;\
                float angle = (percent - 0.5) * 0.25 / (1.0 + exp(-10.0 * (radius / blueRadius - 1.075)));\
                angle -= twopi * twist / (1.0 + exp(-50.0 * (radius / blueRadius - 1.075)));\
                float s = sin(angle), c = cos(angle);\
                vec4 sample = bulgySample(vec2(dot(vec2(c, s), coord), dot(vec2(-s, c), coord)));\
                \
                /* switch to pre-multiplied alpha to correctly blur transparent images */\
                sample.rgb *= sample.a;\
                \
                color += sample * weight;\
                total += weight;\
            }\
            \
            color /= total;\
            gl_FragColor = vec4(colorAt(coord, twist) * dot(vec3(0.2989, 0.5870, 0.1140), 0.25 + 0.75 * color.rgb), color.a);\
            \
            /* switch back from pre-multiplied alpha */\
            gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\
        }\
    ');

    simpleShader.call(this, gl.chromeLogo, {
        center: [centerX, centerY],
        frame: frame,
        blueRadius: blueRadius,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/video/oldfilm.js
/**
 * @filter      Old Film
 * @description Makes the image look like it was projected through an old projector.
 * @param frame The frame number of the animation (the random seed).
 */
function oldFilm(frame) {
    gl.oldFilm = gl.oldFilm || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float frame;\
        varying vec2 texCoord;\
        \
        float random(float scale, float seed) {\
            return fract(sin(seed * scale) * 43758.5453 + seed * 234.45574);\
        }\
        \
        void main() {\
            /* Base color */\
            vec2 offset = (vec2(random(34.534, frame), random(78678.45, frame)) - 0.5) * 0.001;\
            offset.y += 0.1 * pow(0.5 - 0.5 * cos(frame) * cos(frame * 3.178236) * cos(frame * 2.718672), 20.0);\
            vec4 color = texture2D(texture, texCoord + offset);\
            \
            /* Sepia */\
            color.rgb = vec3(\
                dot(color.rgb, vec3(0.393, 0.769, 0.189)),\
                dot(color.rgb, vec3(0.349, 0.686, 0.168)),\
                dot(color.rgb, vec3(0.272, 0.534, 0.131))\
            );\
            \
            /* Vignette */\
            offset = (vec2(random(345.34, frame), random(8204.86, frame)) - 0.5) * 0.01;\
            vec2 darken = abs(texCoord + offset - 0.5) * (2.25 + 0.02 * cos(frame * 0.3));\
            darken = max(vec2(0.0), 1.0 - pow(darken, vec2(5.0)));\
            color.rgb = mix(vec3(0.1), color.rgb, length(darken.x * darken.y));\
            \
            /* Brightness */\
            color.rgb *= 0.75 + 0.25 * cos(frame * 0.1 + cos(frame * 0.4)) * cos(frame / 26.0);\
            \
            /* Lines */\
            float x = (texCoord.x + offset.x) * 100.0;\
            color.rgb *= 1.0 - pow((0.5 - 0.5 * cos(0.025 * frame + 5.0 * x)) * (0.5 - 0.5 * cos(x) * cos(x * 3.178236) * cos(x * 2.718672) * cos(x * 5.728309)), 20.0);\
            \
            /* Specks */\
            vec2 center = vec2(random(6461.345, frame), random(234.2423, frame)) * 2.0;\
            float angle = random(13467.33, frame) * 6.283185307179586;\
            float s = sin(angle), c = cos(angle);\
            vec2 delta = texCoord - center;\
            delta = vec2(dot(vec2(c, s), delta), dot(vec2(-s, c), delta));\
            float shape = 0.9 * random(456.6575, frame);\
            delta.x /= 1.0 - shape;\
            float scale = 200.0 + 200.0 * random(765343.875, frame);\
            float t = scale * length(delta) - 2.0;\
            color.rgb *= smoothstep(0.0, 1.0, t);\
            \
            gl_FragColor = color;\
        }\
    ');

    simpleShader.call(this, gl.oldFilm, {
        frame: frame,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/video/photocopy.js
/**
 * @filter       Photocopy
 * @description  Makes the image look like it was printed by a photocopier.
 * @param cutoff The brightness threshold for the black/white boundary (0 to 1).
 * @param frame  The frame number of the animation (the random seed).
 */
function photocopy(cutoff, frame) {
    gl.photocopy = gl.photocopy || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float frame;\
        uniform float cutoff;\
        varying vec2 texCoord;\
        \
        float random(float scale, float seed) {\
            return fract(sin(seed * scale) * 43758.5453 + seed * 234.45574);\
        }\
        \
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            \
            /* Drum lines */\
            float y = texCoord.y * 300.0;\
            color.rgb *= 1.0 + 0.1 * sin(y) * sin(y * 1.1) + 0.1 * sin(y * 2.317) * sin(y * 1.3648) + 0.1 * sin(y * 0.3673) * sin(y * 0.7836);\
            \
            /* Brightness */\
            color.rgb *= 1.0 + 0.05 * cos(frame * 0.1 + cos(frame * 0.4)) * cos(frame / 26.0);\
            \
            /* Black and white with high contrast */\
            float gray = (color.r + color.g + color.b) / 3.0;\
            color.rgb = vec3(smoothstep(0.0, 1.0, gray * 6.0 - cutoff * 7.0 + 1.0));\
            \
            gl_FragColor = color;\
        }\
    ');

    simpleShader.call(this, gl.photocopy, {
        frame: frame,
        cutoff: clamp(0, cutoff, 1),
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/video/quadcolor.js
/**
 * @filter       Quad Color
 * @description  Renders the image four times, each with a different color.
 * @param color1 An array with three values (0 to 1) for the top-left corner.
 * @param color2 An array with three values (0 to 1) for the top-right corner.
 * @param color3 An array with three values (0 to 1) for the bottom-left corner.
 * @param color4 An array with three values (0 to 1) for the bottom-right corner.
 */
function quadColor(color1, color2, color3, color4) {
    gl.quadColor = gl.quadColor || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec3 color1;\
        uniform vec3 color2;\
        uniform vec3 color3;\
        uniform vec3 color4;\
        varying vec2 texCoord;\
        \
        void main() {\
            vec4 color = texture2D(texture, fract(texCoord * 2.0));\
            color.rgb = vec3((color.r + color.g + color.b) / 3.0);\
            if (texCoord.y < 0.5) {\
                if (texCoord.x < 0.5) color.rgb *= color1;\
                else color.rgb *= color2;\
            } else {\
                if (texCoord.x < 0.5) color.rgb *= color3;\
                else color.rgb *= color4;\
            }\
            gl_FragColor = vec4(color);\
        }\
    ');

    simpleShader.call(this, gl.quadColor, {
        color1: color1,
        color2: color2,
        color3: color3,
        color4: color4
    });

    return this;
}

// src/filters/video/quadrotate.js
/**
 * @filter       Quad Rotate
 * @description  Renders the image four times, each with a configurable orientation.
 * @param quad1  The q
 * @param color2 An array with three values (0 to 1) for the top-right corner.
 * @param color3 An array with three values (0 to 1) for the bottom-left corner.
 * @param color4 An array with three values (0 to 1) for the bottom-right corner.
 */
function quadRotate(dir1, dir2, dir3, dir4) {
    gl.quadRotate = gl.quadRotate || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec4 angles;\
        varying vec2 texCoord;\
        \
        void main() {\
            vec2 coord = fract(texCoord * 2.0) - 0.5;\
            vec2 a = vec2(texCoord.x < 0.5, texCoord.y < 0.5), b = 1.0 - a;\
            float angle = dot(angles, vec4(a.x * a.y, b.x * a.y, a.x * b.y, b.x * b.y));\
            float s = sin(angle), c = cos(angle);\
            coord = vec2(dot(vec2(c, s), coord), dot(vec2(-s, c), coord));\
            gl_FragColor = vec4(texture2D(texture, coord + 0.5));\
        }\
    ');

    simpleShader.call(this, gl.quadRotate, {
        angles: [
            dir1 * Math.PI * 0.5,
            dir2 * Math.PI * 0.5,
            dir3 * Math.PI * 0.5,
            dir4 * Math.PI * 0.5
        ]
    });

    return this;
}

// src/filters/video/timestrips.js
/**
 * @filter         Time Strips
 * @description    Displays many horizontal slices of a video, each from a different frame.
 * @param textures An array containing a circular buffer of frames from a video.
 * @param frame    The index of the first texture in the circular buffer.
 */
function timeStrips(textures, frame) {
    gl.timeStrips = gl.timeStrips || new Shader(null, '\
        uniform sampler2D texture;\
        varying vec2 texCoord;\
        void main() {\
            gl_FragColor = texture2D(texture, texCoord);\
        }\
    ');

    var w = this.width, h = this.height;
    this._.spareTexture.drawTo(function() {
        for (var i = 0; i < textures.length; i++) {
            var texture = textures[(i + frame) % textures.length];
            (texture._ || texture).use();
            gl.timeStrips.drawRect(0, h * i / textures.length, w, h * (i + 1) / textures.length, true);
        }
    });
    this._.spareTexture.swapWith(this._.texture);

    return this;
}

// src/filters/video/vhs.js
/**
 * @filter      VHS
 * @description Makes the image look like it was captured on VHS.
 * @param frame The frame number of the animation (the random seed).
 */
function vhs(frame) {
    gl.vhs = gl.vhs || new Shader(null, '\
        uniform sampler2D texture;\
        uniform float frame;\
        varying vec2 texCoord;\
        \
        float random(float scale, float seed) {\
            return fract(sin(seed * scale) * 43758.5453 + seed * 234.45574);\
        }\
        \
        void main() {\
            /* RGB to YCbCr */\
            vec4 color = texture2D(texture, texCoord);\
            vec3 rgb = color.rgb * 256.0;\
            vec3 ycbcr = vec3(\
                dot(vec3(0.299, 0.587, 0.114), rgb),\
                128.0 + dot(vec3(-0.1687, -0.3313, 0.5), rgb),\
                128.0 + dot(vec3(0.5, -0.4187, -0.0813), rgb)\
            );\
            \
            /* Color dimming */\
            ycbcr = mix(vec3(128.0), ycbcr, vec3(0.75, 0.5, 0.5));\
            \
            /* Scan lines */\
            float y = texCoord.y + frame * 0.005;\
            ycbcr.x *= 1.0 + 0.075 * sin(y * 300.0 + frame * 11.0) * sin(y * 70.0) * sin(y * 10.0);\
            \
            /* Phosphor pattern */\
            ycbcr.x *= 1.0 + 0.25 * sin(dot(vec2(3.0, 1.0), gl_FragCoord.xy));\
            \
            /* YCbCr to RGB */\
            rgb = vec3(\
                ycbcr.x + 1.402 * (ycbcr.z - 128.0),\
                ycbcr.x - 0.34414 * (ycbcr.y - 128.0) - 0.71414 * (ycbcr.z - 128.0),\
                ycbcr.x + 1.772 * (ycbcr.y - 128.0)\
            );\
            gl_FragColor = vec4(rgb / 256.0, color.a);\
        }\
    ');

    // VHS is low resolution and runs a sharpening filter
    triangleBlur.call(this, 5);
    unsharpMask.call(this, 5, 10);

    simpleShader.call(this, gl.vhs, {
        frame: frame,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/video/wettable.js
/**
 * @filter         Wet Table
 * @description    Uses the scene to generate an image of a wet table.
 */
function wetTable() {
    gl.wetTableGrayscale = gl.wetTableGrayscale || new Shader(null, '\
        uniform sampler2D texture;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            float gray = dot(vec3(0.2989, 0.5870, 0.1140), color.rgb);\
            gl_FragColor = vec4(gray);\
        }\
    ');

    gl.wetTableThreshold = gl.wetTableThreshold || new Shader(null, '\
        uniform sampler2D texture;\
        varying vec2 texCoord;\
        void main() {\
            vec4 color = texture2D(texture, texCoord);\
            gl_FragColor = vec4(float(fract(color.r * 4.0) > 0.5));\
        }\
    ');

    gl.wetTableBlur = gl.wetTableBlur || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 delta;\
        varying vec2 texCoord;\
        void main() {\
            vec4 centerSample = texture2D(texture, texCoord);\
            float color = centerSample.r;\
            float total = 1.0;\
            for (float t = 1.5; t < 11.5; t += 2.0) {\
                float weight = 2.0 * exp(-t * t * 0.02);\
                color += texture2D(texture, texCoord + delta * t).r * weight;\
                color += texture2D(texture, texCoord - delta * t).r * weight;\
                total += 2.0 * weight;\
            }\
            gl_FragColor = vec4(color / total, centerSample.g, 0.0, 1.0);\
        }\
    ');

    gl.wetTable = gl.wetTable || new Shader(null, '\
        uniform sampler2D texture;\
        uniform sampler2D envMap;\
        varying vec2 texCoord;\
        \
        void main() {\
            vec2 delta = texCoord / gl_FragCoord.xy;\
            vec4 data = texture2D(texture, texCoord);\
            vec4 xneg = texture2D(texture, texCoord - vec2(delta.x, 0.0));\
            vec4 xpos = texture2D(texture, texCoord + vec2(delta.x, 0.0));\
            vec4 yneg = texture2D(texture, texCoord - vec2(0.0, delta.y));\
            vec4 ypos = texture2D(texture, texCoord + vec2(0.0, delta.y));\
            float isOutside = clamp(15.0 * (data.r - 0.5), 0.0, 1.0);\
            float depth = 0.3;\
            vec3 normal = normalize(cross(vec3(depth, 0.0, xpos.r - xneg.r), vec3(0.0, depth, ypos.r - yneg.r)));\
            \
            float shadow = texture2D(texture, texCoord - vec2(0, delta.y * 5.0)).r;\
            vec2 coord = gl_FragCoord.xy * 0.02;\
            vec3 ray = refract(vec3(0.0, 0.0, -1.0), normal, 1.65);\
            coord += ray.xy / ray.z * (data.r - 0.5) * (1.0 - isOutside);\
            float pattern = (float(fract(coord.x) > 0.5) + float(fract(coord.y) > 0.5)) * 0.5;\
            vec3 outsideColor = mix(vec3(0.75, 0.25, 0.25), vec3(0.85), pattern);\
            \
            ray = reflect(vec3(0.0, 0.0, -1.0), normal);\
            vec2 roof = ray.xz / (ray.y + 0.00001);\
            float dist = min(min(length(roof - vec2(-2.0, 1.0)), length(roof - vec2(0.5, 1.0))),\
                             min(length(roof - vec2(1.0, 2.0)), length(roof - vec2(-1.0, 1.0))));\
            float light = 1.0 / (0.1 + 10.0 * dist);\
            vec3 insideColor = outsideColor * (0.25 + 0.85 * ray.z) + light;\
            insideColor += 0.125 - 0.125 / (1.0 + exp(-30.0 * (ray.x * 0.25 + ray.y + 0.5)));\
            insideColor += pow(max(0.0, ray.y), 10.0) * 0.5 - max(0.0, -ray.y) * 0.25;\
            \
            gl_FragColor = vec4(mix(insideColor, outsideColor * (0.5 + 0.5 * pow(shadow, 0.25)), isOutside), 1.0);\
        }\
    ');

    simpleShader.call(this, gl.wetTableGrayscale);
    simpleShader.call(this, gl.wetTableBlur, { delta: [1 / this.width, 0] });
    simpleShader.call(this, gl.wetTableBlur, { delta: [0, 1 / this.height] });
    simpleShader.call(this, gl.wetTableThreshold);
    simpleShader.call(this, gl.wetTableBlur, { delta: [1 / this.width, 0] });
    simpleShader.call(this, gl.wetTableBlur, { delta: [0, 1 / this.height] });
    simpleShader.call(this, gl.wetTable);

    return this;
}

// src/filters/warp/blockhead.js
/**
 * @filter         Blockhead
 * @description    Bulges or pinches the image in a rectangle.
 * @param centerX  The x coordinate of the center of the rectangle of effect.
 * @param centerY  The y coordinate of the center of the rectangle of effect.
 * @param width    The width of the rectangle of effect.
 * @param height   The height of the rectangle of effect.
 * @param strength -1 to 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)
 */
function blockhead(centerX, centerY, width, height, strength) {
    gl.blockhead = gl.blockhead || warpShader('\
        uniform vec2 radius;\
        uniform float strength;\
        uniform vec2 center;\
        float warp(float coord) {\
            float percent = abs(coord);\
            if (percent < 1.0) {\
                float factor = mix(1.0, smoothstep(0.0, 1.0, percent), abs(strength) * 0.75);\
                if (strength > 0.0) coord *= factor;\
                else coord /= factor;\
            }\
            return coord;\
        }\
    ', '\
        coord = (coord - center) / radius;\
        coord.x = warp(coord.x);\
        coord.y = warp(coord.y);\
        coord = coord * radius + center;\
    ');

    simpleShader.call(this, gl.blockhead, {
        radius: [width / 2, height / 2],
        strength: clamp(-1, strength, 1),
        center: [centerX, centerY],
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/warp/bulgepinch.js
/**
 * @filter         Bulge / Pinch
 * @description    Bulges or pinches the image in a circle.
 * @param centerX  The x coordinate of the center of the circle of effect.
 * @param centerY  The y coordinate of the center of the circle of effect.
 * @param radius   The radius of the circle of effect.
 * @param strength -1 to 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)
 */
function bulgePinch(centerX, centerY, radius, strength) {
    gl.bulgePinch = gl.bulgePinch || warpShader('\
        uniform float radius;\
        uniform float strength;\
        uniform vec2 center;\
    ', '\
        coord -= center;\
        float distance = length(coord);\
        if (distance < radius) {\
            float percent = distance / radius;\
            if (strength > 0.0) {\
                coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\
            } else {\
                coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\
            }\
        }\
        coord += center;\
    ');

    simpleShader.call(this, gl.bulgePinch, {
        radius: radius,
        strength: clamp(-1, strength, 1),
        center: [centerX, centerY],
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/warp/kaleidoscope.js
/**
 * @filter         Kaleidoscope
 * @description    Renders the image as if looked at through a kaleidoscope
 *                 (a tube with three mirrors inside arranged in a triangle).
 * @param centerX  The x coordinate of the center of the triangular pattern.
 * @param centerY  The y coordinate of the center of the triangular pattern.
 * @param size     The length of one side of a triangle.
 * @param angle    The rotation of the triangular pattern, in radians.
 */
function kaleidoscope(centerX, centerY, size, angle) {
    gl.kaleidoscope = gl.kaleidoscope || warpShader('\
        uniform float size;\
        uniform float angle;\
        uniform vec2 center;\
        bool xor(bool a, bool b) { return (int(a) + int(b)) == 1; }\
    ', '\
        float c = cos(angle);\
        float s = sin(angle);\
        \
        /* Convert to triangle coordinates */\
        coord = (coord - center) / size;\
        coord = vec2(dot(vec2(c, s), coord), dot(vec2(-s, c), coord));\
        coord.y /= 0.866025404;\
        coord.x -= coord.y * 0.5;\
        \
        /* Apply mirrored reflections */\
        coord = 3.0 * fract(coord / 3.0);\
        if (coord.x + coord.y > 3.0) coord = 3.0 - coord.yx;\
        if (coord.x + coord.y > 2.0) coord = 2.0 - coord.yx;\
        if (coord.x > 1.0) {\
            if (coord.y > 0.0) coord = vec2(2.0 - coord.x - coord.y, coord.x - 1.0);\
            else coord = vec2(2.0 - coord.x, coord.x + coord.y - 1.0);\
        }\
        else if (coord.y > 1.0) {\
            if (coord.x > 0.0) coord = vec2(coord.y - 1.0, 2.0 - coord.x - coord.y);\
            else coord = vec2(coord.x + coord.y - 1.0, 2.0 - coord.y);\
        }\
        else if (coord.x + coord.y > 1.0) coord = 1.0 - coord.yx;\
        \
        /* Convert from triangle coordinates */\
        coord.x += coord.y * 0.5;\
        coord.y *= 0.866025404;\
        coord = vec2(dot(vec2(c, -s), coord), dot(vec2(s, c), coord));\
        coord = coord * size + center;\
    ');

    simpleShader.call(this, gl.kaleidoscope, {
        size: size,
        angle: angle,
        center: [centerX, centerY],
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/warp/matrixwarp.js
/**
 * @filter                Matrix Warp
 * @description           Transforms an image by a 2x2 or 3x3 matrix. The coordinates used in
 *                        the transformation are (x, y) for a 2x2 matrix or (x, y, 1) for a
 *                        3x3 matrix, where x and y are in units of pixels.
 * @param matrix          A 2x2 or 3x3 matrix represented as either a list or a list of lists.
 *                        For example, the 3x3 matrix [[2,0,0],[0,3,0],[0,0,1]] can also be
 *                        represented as [2,0,0,0,3,0,0,0,1] or just [2,0,0,3].
 * @param inverse         A boolean value that, when true, applies the inverse transformation
 *                        instead. (optional, defaults to false)
 * @param useTextureSpace A boolean value that, when true, uses texture-space coordinates
 *                        instead of screen-space coordinates. Texture-space coordinates range
 *                        from -1 to 1 instead of 0 to width - 1 or height - 1, and are easier
 *                        to use for simple operations like flipping and rotating.
 */
function matrixWarp(matrix, inverse, useTextureSpace) {
    gl.matrixWarp = gl.matrixWarp || warpShader('\
        uniform mat3 matrix;\
        uniform float useTextureSpace;\
    ', '\
        if (useTextureSpace > 0.5) coord = coord / texSize * 2.0 - 1.0;\
        vec3 warp = matrix * vec3(coord, 1.0);\
        coord = warp.xy / warp.z;\
        if (useTextureSpace > 0.5) coord = (coord * 0.5 + 0.5) * texSize;\
    ');

    // Flatten all members of matrix into one big list
    matrix = Array.prototype.concat.apply([], matrix);

    // Extract a 3x3 matrix out of the arguments
    if (matrix.length == 4) {
        matrix = [
            matrix[0], matrix[1], 0,
            matrix[2], matrix[3], 0,
            0, 0, 1
        ];
    } else if (matrix.length != 9) {
        throw 'can only warp with 2x2 or 3x3 matrix';
    }

    simpleShader.call(this, gl.matrixWarp, {
        matrix: inverse ? getInverse(matrix) : matrix,
        texSize: [this.width, this.height],
        useTextureSpace: useTextureSpace | 0
    });

    return this;
}

// src/filters/warp/mirror.js
/**
 * @filter      Mirror
 * @description Mirrors the image about a line.
 * @param angle The angle of the line of symmetry, in radians.
 */
function mirror(angle) {
    gl.mirror = gl.mirror || warpShader('\
        uniform float angle;\
    ', '\
        coord -= texSize * 0.5;\
        vec2 dir = vec2(cos(angle), sin(angle));\
        float dist = dot(dir, coord);\
        if (dist < 0.0) coord -= dir * dist * 2.0;\
        coord += texSize * 0.5;\
    ');

    simpleShader.call(this, gl.mirror, {
        angle: angle,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/warp/mirrortube.js
/**
 * @filter        Mirror Tube
 * @description   Mirrors everything around a circle back inside the circle.
 * @param centerX The x coordinate of the center of the circle.
 * @param centerY The y coordinate of the center of the circle.
 * @param radius  The radius of the circle.
 */
function mirrorTube(centerX, centerY, radius) {
    gl.mirrorTube = gl.mirrorTube || new Shader(null, '\
        uniform sampler2D texture;\
        uniform vec2 center;\
        uniform float radius;\
        uniform vec2 texSize;\
        varying vec2 texCoord;\
        void main() {\
            vec2 coord = texCoord * texSize - center;\
            float t = length(coord) / radius;\
            coord *= smoothstep(0.0, t, 1.0 / t);\
            gl_FragColor = texture2D(texture, (coord + center) / texSize);\
        }\
    ');

    simpleShader.call(this, gl.mirrorTube, {
        center: [centerX, centerY],
        radius: radius,
        texSize: [this.width, this.height]
    });

    return this;
}

// src/filters/warp/perspective.js
/**
 * @filter       Perspective
 * @description  Warps one quadrangle to another with a perspective transform. This can be used to
 *               make a 2D image look 3D or to recover a 2D image captured in a 3D environment.
 * @param before The x and y coordinates of four points before the transform in a flat list. This
 *               would look like [ax, ay, bx, by, cx, cy, dx, dy] for four points (ax, ay), (bx, by),
 *               (cx, cy), and (dx, dy).
 * @param after  The x and y coordinates of four points after the transform in a flat list, just
 *               like the other argument.
 */
function perspective(before, after) {
    var a = getSquareToQuad.apply(null, after);
    var b = getSquareToQuad.apply(null, before);
    var c = multiply(getInverse(a), b);
    return this.matrixWarp(c);
}

// src/filters/warp/swirl.js
/**
 * @filter        Swirl
 * @description   Warps a circular region of the image in a swirl.
 * @param centerX The x coordinate of the center of the circular region.
 * @param centerY The y coordinate of the center of the circular region.
 * @param radius  The radius of the circular region.
 * @param angle   The angle in radians that the pixels in the center of
 *                the circular region will be rotated by.
 */
function swirl(centerX, centerY, radius, angle) {
    gl.swirl = gl.swirl || warpShader('\
        uniform float radius;\
        uniform float angle;\
        uniform vec2 center;\
    ', '\
        coord -= center;\
        float distance = length(coord);\
        if (distance < radius) {\
            float percent = (radius - distance) / radius;\
            float theta = percent * percent * angle;\
            float s = sin(theta);\
            float c = cos(theta);\
            coord = vec2(\
                coord.x * c - coord.y * s,\
                coord.x * s + coord.y * c\
            );\
        }\
        coord += center;\
    ');

    simpleShader.call(this, gl.swirl, {
        radius: radius,
        center: [centerX, centerY],
        angle: angle,
        texSize: [this.width, this.height]
    });

    return this;
}

return exports;
})();
